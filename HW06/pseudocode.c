顾客信号量 = 0
理发师信号量 = 0
互斥信号量mutex = 1 // 椅子是理发师和顾客精进程都可以访问的临界区 
int 空椅子数量 = N     //所有的椅子数量  

理发师（线程 / 进程）
While(true) {        //持续不断地循环  
		P（顾客）          //试图为一位顾客服务，如果没有他就睡觉（进程阻塞）  
		P（互斥信号量）     //如果有顾客，这时他被叫醒（理发师进程被唤醒），要修改空椅子的数量  
		空椅子数量++     //一张椅子空了出来  
		V（理发师）        //现在有一个醒着的理发师，理发师准备理发，多个顾客可以竞争理发师互斥量，但是只有一个顾客进程可以被唤醒并得到服务  
		V（互斥信号量）    //释放椅子互斥量，使得进店的顾客可以访问椅子的数量以决定是否进店等待 
		/* 理发师在理发 */
		｝


		顾客（线程 / 进程）
		while (true)
		{   //持续不断地循环  
			P（互斥信号量）     //想坐到一张椅子上 
				if (空椅子数量 > 0)
				{ //如果还有空着的椅子的话  
					空椅子数量--        //顾客坐到一张椅子上了  
						V（顾客）           //通知理发师，有一位顾客来了  
						V（互斥信号量）     //顾客已经坐在椅子上等待了，访问椅子结束，释放互斥量  
						P（理发师）         //该这位顾客理发了，如果理发师还在忙，那么他就等着（顾客进程阻塞）  
						/* 竞争到了理发师则该顾客开始理发 */
				}
				else
				{   //没有空着的椅子  
					V（互斥信号标）     //不要忘记释放被锁定的椅子  
					/* 顾客没有理发就走了 */
				}
		}
}
————————————————
// 版权声明：本文为CSDN博主「Cristiano - Duan」的原创文章，遵循CC 4.0 BY - SA版权协议，转载请附上原文出处链接及本声明。
// 原文链接：https ://blog.csdn.net/duanzhengbing/article/details/52141699